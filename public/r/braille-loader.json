{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "braille-loader",
  "title": "Braille Loader",
  "description": "Accessible braille-inspired loading indicator with 15 animation variants.",
  "files": [
    {
      "path": "registry/new-york/ui/braille-loader.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\n\nimport {\n  type BrailleGrid,\n  type BrailleGridSize,\n  type BrailleLoaderSpeed,\n  type BrailleLoaderVariant,\n  getFrameCount,\n  getFrameMs,\n  getReducedMotionFrame,\n  isDotActive,\n  normalizeVariant,\n  resolveGrid,\n} from \"@/lib/braille-loader\"\nimport { cn } from \"@/lib/utils\"\n\ntype BrailleLoaderProps = React.ComponentProps<\"div\"> & {\n  variant?: BrailleLoaderVariant\n  size?: \"sm\" | \"md\" | \"lg\"\n  gridSize?: BrailleGridSize\n  grid?: BrailleGrid\n  speed?: BrailleLoaderSpeed\n  dotClassName?: string\n  label?: string\n}\n\nconst sizeVars = {\n  sm: { dot: \"5px\", gap: \"4px\", radius: \"9999px\" },\n  md: { dot: \"7px\", gap: \"5px\", radius: \"9999px\" },\n  lg: { dot: \"10px\", gap: \"6px\", radius: \"9999px\" },\n} as const\n\nfunction usePrefersReducedMotion() {\n  const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(false)\n\n  React.useEffect(() => {\n    if (typeof window === \"undefined\") {\n      return\n    }\n\n    const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\")\n    const onChange = () => setPrefersReducedMotion(mediaQuery.matches)\n\n    onChange()\n    mediaQuery.addEventListener(\"change\", onChange)\n\n    return () => mediaQuery.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return prefersReducedMotion\n}\n\nfunction BrailleLoader({\n  variant = \"braille\",\n  size = \"md\",\n  gridSize = \"md\",\n  grid,\n  speed = \"normal\",\n  dotClassName,\n  className,\n  label = \"Loading\",\n  style,\n  ...props\n}: BrailleLoaderProps) {\n  const resolvedVariant = normalizeVariant(variant)\n  const [rows, cols] = resolveGrid(gridSize, grid)\n  const frameCount = getFrameCount(resolvedVariant, rows, cols)\n  const prefersReducedMotion = usePrefersReducedMotion()\n  const [frameIndex, setFrameIndex] = React.useState(0)\n\n  React.useEffect(() => {\n    if (prefersReducedMotion) {\n      return\n    }\n\n    const intervalMs = getFrameMs(resolvedVariant, speed)\n    const timer = window.setInterval(() => {\n      setFrameIndex((current) => (current + 1) % frameCount)\n    }, intervalMs)\n\n    return () => window.clearInterval(timer)\n  }, [frameCount, prefersReducedMotion, resolvedVariant, speed, rows, cols])\n\n  const resolvedSize = sizeVars[size]\n  const staticFrame = React.useMemo(\n    () => new Set(getReducedMotionFrame(resolvedVariant, rows, cols)),\n    [resolvedVariant, rows, cols]\n  )\n  const totalCells = rows * cols\n\n  return (\n    <div\n      role=\"status\"\n      aria-live=\"polite\"\n      className={cn(\"inline-flex items-center text-current\", className)}\n      style={\n        {\n          \"--bl-dot-size\": resolvedSize.dot,\n          \"--bl-gap\": resolvedSize.gap,\n          \"--bl-dot-radius\": resolvedSize.radius,\n          ...style,\n        } as React.CSSProperties\n      }\n      {...props}\n    >\n      <span className=\"sr-only\">{label}</span>\n      <div\n        aria-hidden=\"true\"\n        className=\"grid\"\n        style={{\n          gap: \"var(--bl-gap)\",\n          gridTemplateColumns: `repeat(${cols}, var(--bl-dot-size))`,\n          gridTemplateRows: `repeat(${rows}, var(--bl-dot-size))`,\n        }}\n      >\n        {Array.from({ length: totalCells }, (_, dotIndex) => {\n          const active = prefersReducedMotion\n            ? staticFrame.has(dotIndex)\n            : isDotActive(resolvedVariant, frameIndex, dotIndex, rows, cols)\n\n          return (\n            <span\n              key={dotIndex}\n              className={cn(\n                \"bg-current transition-opacity duration-150 ease-linear\",\n                active ? \"opacity-90\" : \"opacity-20\",\n                dotClassName\n              )}\n              style={{\n                width: \"var(--bl-dot-size)\",\n                height: \"var(--bl-dot-size)\",\n                borderRadius: \"var(--bl-dot-radius)\",\n              }}\n            />\n          )\n        })}\n      </div>\n    </div>\n  )\n}\n\nexport { BrailleLoader, type BrailleLoaderProps }\n",
      "type": "registry:component"
    },
    {
      "path": "lib/braille-loader.ts",
      "content": "export const brailleLoaderVariants = [\n  \"braille\",\n  \"orbit\",\n  \"breathe\",\n  \"snake\",\n  \"fill-sweep\",\n  \"pulse\",\n  \"columns\",\n  \"checkerboard\",\n  \"scan\",\n  \"rain\",\n  \"cascade\",\n  \"sparkle\",\n  \"wave-rows\",\n  \"helix\",\n  \"diagonal-swipe\",\n] as const\n\nexport type BrailleLoaderVariant = (typeof brailleLoaderVariants)[number]\nexport type BrailleLoaderSpeed = \"slow\" | \"normal\" | \"fast\"\nexport type BrailleGridSize = \"sm\" | \"md\" | \"lg\" | \"xl\"\nexport type BrailleGrid = [rows: number, cols: number]\n\ntype VariantConfig = {\n  stepMultiplier?: number\n}\n\nconst GRID_PRESETS: Record<BrailleGridSize, BrailleGrid> = {\n  sm: [3, 3],\n  md: [4, 4],\n  lg: [5, 5],\n  xl: [6, 6],\n}\n\nconst MIN_GRID_DIMENSION = 2\nconst MAX_GRID_DIMENSION = 12\n\nconst variantConfig: Record<BrailleLoaderVariant, VariantConfig> = {\n  braille: { stepMultiplier: 1 },\n  orbit: { stepMultiplier: 0.9 },\n  breathe: { stepMultiplier: 1.15 },\n  snake: { stepMultiplier: 0.9 },\n  \"fill-sweep\": { stepMultiplier: 0.95 },\n  pulse: { stepMultiplier: 1 },\n  columns: { stepMultiplier: 1 },\n  checkerboard: { stepMultiplier: 1.05 },\n  scan: { stepMultiplier: 0.9 },\n  rain: { stepMultiplier: 0.85 },\n  cascade: { stepMultiplier: 0.9 },\n  sparkle: { stepMultiplier: 0.95 },\n  \"wave-rows\": { stepMultiplier: 1 },\n  helix: { stepMultiplier: 0.9 },\n  \"diagonal-swipe\": { stepMultiplier: 0.95 },\n}\n\ntype Frame = number[]\n\nconst frameCache = new Map<string, Frame[]>()\n\nexport const speedToMs: Record<BrailleLoaderSpeed, number> = {\n  slow: 220,\n  normal: 140,\n  fast: 90,\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(max, Math.max(min, value))\n}\n\nfunction toIndex(row: number, col: number, cols: number): number {\n  return row * cols + col\n}\n\nfunction keyFor(variant: BrailleLoaderVariant, rows: number, cols: number): string {\n  return `${variant}:${rows}x${cols}`\n}\n\nfunction range(length: number): number[] {\n  return Array.from({ length }, (_, index) => index)\n}\n\nfunction uniqueFrame(values: number[]): Frame {\n  return [...new Set(values)].sort((a, b) => a - b)\n}\n\nfunction perimeterPath(rows: number, cols: number): number[] {\n  const path: number[] = []\n\n  for (let col = 0; col < cols; col += 1) {\n    path.push(toIndex(0, col, cols))\n  }\n  for (let row = 1; row < rows - 1; row += 1) {\n    path.push(toIndex(row, cols - 1, cols))\n  }\n  if (rows > 1) {\n    for (let col = cols - 1; col >= 0; col -= 1) {\n      path.push(toIndex(rows - 1, col, cols))\n    }\n  }\n  if (cols > 1) {\n    for (let row = rows - 2; row >= 1; row -= 1) {\n      path.push(toIndex(row, 0, cols))\n    }\n  }\n\n  return uniqueFrame(path).length === path.length ? path : [...new Set(path)]\n}\n\nfunction snakePath(rows: number, cols: number): number[] {\n  const path: number[] = []\n\n  for (let row = 0; row < rows; row += 1) {\n    const columns = range(cols)\n    const ordered = row % 2 === 0 ? columns : columns.reverse()\n    for (const col of ordered) {\n      path.push(toIndex(row, col, cols))\n    }\n  }\n\n  return path\n}\n\nfunction diagonalBands(rows: number, cols: number): number[][] {\n  const count = rows + cols - 1\n  return range(count).map((sum) => {\n    const frame: number[] = []\n    for (let row = 0; row < rows; row += 1) {\n      const col = sum - row\n      if (col >= 0 && col < cols) {\n        frame.push(toIndex(row, col, cols))\n      }\n    }\n    return frame\n  })\n}\n\nfunction antiDiagonalBands(rows: number, cols: number): number[][] {\n  const count = rows + cols - 1\n  return range(count).map((difference) => {\n    const frame: number[] = []\n    for (let row = 0; row < rows; row += 1) {\n      const col = row - difference + (cols - 1)\n      if (col >= 0 && col < cols) {\n        frame.push(toIndex(row, col, cols))\n      }\n    }\n    return frame\n  })\n}\n\nfunction lcg(seed: number) {\n  let state = seed\n  return () => {\n    state = (state * 1664525 + 1013904223) % 0x100000000\n    return state / 0x100000000\n  }\n}\n\nfunction buildBrailleFrames(rows: number, cols: number): Frame[] {\n  const path = snakePath(rows, cols)\n  const total = path.length\n  const steps = [\n    clamp(Math.floor(total * 0.15), 1, total),\n    clamp(Math.floor(total * 0.35), 1, total),\n    clamp(Math.floor(total * 0.55), 1, total),\n    clamp(Math.floor(total * 0.75), 1, total),\n    total,\n  ]\n\n  return [...steps, ...steps.slice(0, -1).reverse()].map((count) =>\n    path.slice(0, count)\n  )\n}\n\nfunction buildOrbitFrames(rows: number, cols: number): Frame[] {\n  const path = perimeterPath(rows, cols)\n  const trail = clamp(Math.floor(path.length / 5), 2, Math.max(2, path.length - 1))\n\n  return path.map((_, index) => {\n    const frame = range(trail).map((offset) => {\n      const point = path[(index - offset + path.length) % path.length]\n      return point\n    })\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildBreatheFrames(rows: number, cols: number): Frame[] {\n  const centerRow = (rows - 1) / 2\n  const centerCol = (cols - 1) / 2\n  const maxDistance = Math.max(centerRow, centerCol) || 1\n  const levels = [0.3, 0.55, 0.8, 1, 0.8, 0.55]\n\n  return levels.map((level) => {\n    const threshold = maxDistance * level\n    const frame: number[] = []\n    for (let row = 0; row < rows; row += 1) {\n      for (let col = 0; col < cols; col += 1) {\n        const distance = Math.max(\n          Math.abs(row - centerRow),\n          Math.abs(col - centerCol)\n        )\n        if (distance <= threshold) {\n          frame.push(toIndex(row, col, cols))\n        }\n      }\n    }\n    return frame\n  })\n}\n\nfunction buildSnakeFrames(rows: number, cols: number): Frame[] {\n  const path = snakePath(rows, cols)\n  const trailLength = clamp(Math.floor(path.length / 4), 3, 8)\n\n  return path.map((_, index) => {\n    const frame = range(trailLength).map((offset) => {\n      const point = path[(index - offset + path.length) % path.length]\n      return point\n    })\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildFillSweepFrames(rows: number, cols: number): Frame[] {\n  const forward = range(cols + 1).map((step) => {\n    const frame: number[] = []\n    for (let row = 0; row < rows; row += 1) {\n      for (let col = 0; col < step; col += 1) {\n        frame.push(toIndex(row, col, cols))\n      }\n    }\n    return frame\n  })\n\n  const backward = range(cols).map((index) => cols - 1 - index).map((step) => {\n    const frame: number[] = []\n    for (let row = 0; row < rows; row += 1) {\n      for (let col = step; col < cols; col += 1) {\n        frame.push(toIndex(row, col, cols))\n      }\n    }\n    return frame\n  })\n\n  return [...forward, ...backward]\n}\n\nfunction buildPulseFrames(rows: number, cols: number): Frame[] {\n  const centerRow = (rows - 1) / 2\n  const centerCol = (cols - 1) / 2\n  const maxDistance = Math.max(\n    Math.abs(0 - centerRow) + Math.abs(0 - centerCol),\n    Math.abs(rows - 1 - centerRow) + Math.abs(cols - 1 - centerCol)\n  )\n  const levels = [0.2, 0.45, 0.75, 1, 0.75, 0.45]\n\n  return levels.map((ratio) => {\n    const threshold = maxDistance * ratio\n    const frame: number[] = []\n    for (let row = 0; row < rows; row += 1) {\n      for (let col = 0; col < cols; col += 1) {\n        const distance = Math.abs(row - centerRow) + Math.abs(col - centerCol)\n        if (distance <= threshold) {\n          frame.push(toIndex(row, col, cols))\n        }\n      }\n    }\n    return frame\n  })\n}\n\nfunction buildColumnsFrames(rows: number, cols: number): Frame[] {\n  const evenColumns: number[] = []\n  const oddColumns: number[] = []\n  const leftColumns: number[] = []\n  const rightColumns: number[] = []\n  const mid = Math.floor(cols / 2)\n\n  for (let row = 0; row < rows; row += 1) {\n    for (let col = 0; col < cols; col += 1) {\n      const index = toIndex(row, col, cols)\n      if (col % 2 === 0) evenColumns.push(index)\n      if (col % 2 === 1) oddColumns.push(index)\n      if (col < mid) leftColumns.push(index)\n      if (col >= cols - mid) rightColumns.push(index)\n    }\n  }\n\n  return [evenColumns, oddColumns, leftColumns, rightColumns]\n}\n\nfunction buildCheckerboardFrames(rows: number, cols: number): Frame[] {\n  const even: number[] = []\n  const odd: number[] = []\n\n  for (let row = 0; row < rows; row += 1) {\n    for (let col = 0; col < cols; col += 1) {\n      if ((row + col) % 2 === 0) {\n        even.push(toIndex(row, col, cols))\n      } else {\n        odd.push(toIndex(row, col, cols))\n      }\n    }\n  }\n\n  return [even, odd]\n}\n\nfunction buildScanFrames(rows: number, cols: number): Frame[] {\n  const down = range(rows).map((row) =>\n    range(cols).map((col) => toIndex(row, col, cols))\n  )\n  const up = range(Math.max(rows - 2, 0))\n    .map((index) => rows - 2 - index)\n    .map((row) => range(cols).map((col) => toIndex(row, col, cols)))\n\n  return [...down, ...up]\n}\n\nfunction buildRainFrames(rows: number, cols: number): Frame[] {\n  const frameCount = Math.max(rows * 2, 8)\n  const random = lcg(rows * 131 + cols * 17)\n  const phases = range(cols).map(() => Math.floor(random() * rows))\n  const speeds = range(cols).map(() => 1 + Math.floor(random() * 2))\n\n  return range(frameCount).map((frameIndex) => {\n    const frame: number[] = []\n    for (let col = 0; col < cols; col += 1) {\n      const row = (phases[col] + frameIndex * speeds[col]) % rows\n      frame.push(toIndex(row, col, cols))\n      if (row > 0) {\n        frame.push(toIndex(row - 1, col, cols))\n      }\n    }\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildCascadeFrames(rows: number, cols: number): Frame[] {\n  const bands = diagonalBands(rows, cols)\n  const thickness = 2\n\n  return bands.map((_, index) => {\n    const frame: number[] = []\n    for (let offset = 0; offset < thickness; offset += 1) {\n      const band = bands[(index - offset + bands.length) % bands.length]\n      frame.push(...band)\n    }\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildSparkleFrames(rows: number, cols: number): Frame[] {\n  const frameCount = Math.max(rows + cols + 4, 10)\n  const random = lcg(rows * 911 + cols * 3571)\n  const total = rows * cols\n\n  return range(frameCount).map((frameIndex) => {\n    const burst = frameIndex % 5 === 0\n    const points = burst\n      ? clamp(Math.floor(total * 0.4), 4, total)\n      : clamp(Math.floor(total * 0.15), 2, 8)\n    const frame: number[] = []\n\n    for (let i = 0; i < points; i += 1) {\n      frame.push(Math.floor(random() * total))\n    }\n\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildWaveRowsFrames(rows: number, cols: number): Frame[] {\n  const frames = Math.max(cols * 2, 8)\n  const phases = range(rows).map((row) => (row / Math.max(rows, 1)) * Math.PI)\n\n  return range(frames).map((frameIndex) => {\n    const frame: number[] = []\n    const t = (frameIndex / frames) * 2 * Math.PI\n\n    for (let row = 0; row < rows; row += 1) {\n      const signal = (Math.sin(t + phases[row]) + 1) / 2\n      const col = Math.round(signal * (cols - 1))\n      frame.push(toIndex(row, col, cols))\n      if (col + 1 < cols) {\n        frame.push(toIndex(row, col + 1, cols))\n      }\n    }\n\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildHelixFrames(rows: number, cols: number): Frame[] {\n  const path = perimeterPath(rows, cols)\n  const half = Math.floor(path.length / 2)\n  const wing = clamp(Math.floor(path.length / 8), 1, 4)\n\n  return path.map((_, index) => {\n    const frame: number[] = []\n    const leadA = path[index]\n    const leadB = path[(index + half) % path.length]\n    frame.push(leadA, leadB)\n\n    for (let offset = 1; offset <= wing; offset += 1) {\n      frame.push(path[(index + offset) % path.length])\n      frame.push(path[(index - offset + path.length) % path.length])\n      frame.push(path[(index + half + offset) % path.length])\n      frame.push(path[(index + half - offset + path.length) % path.length])\n    }\n\n    return uniqueFrame(frame)\n  })\n}\n\nfunction buildDiagonalSwipeFrames(rows: number, cols: number): Frame[] {\n  const bands = antiDiagonalBands(rows, cols)\n  const reveal = bands.map((_, step) => uniqueFrame(bands.slice(0, step + 1).flat()))\n  const conceal = bands\n    .map((_, index) => index + 1)\n    .map((step) => uniqueFrame(bands.slice(step).flat()))\n\n  return [...reveal, ...conceal]\n}\n\nfunction getFrames(variant: BrailleLoaderVariant, rows: number, cols: number): Frame[] {\n  const cacheKey = keyFor(variant, rows, cols)\n  const cached = frameCache.get(cacheKey)\n  if (cached) {\n    return cached\n  }\n\n  const frames: Frame[] =\n    variant === \"braille\"\n      ? buildBrailleFrames(rows, cols)\n      : variant === \"orbit\"\n        ? buildOrbitFrames(rows, cols)\n        : variant === \"breathe\"\n          ? buildBreatheFrames(rows, cols)\n          : variant === \"snake\"\n            ? buildSnakeFrames(rows, cols)\n            : variant === \"fill-sweep\"\n              ? buildFillSweepFrames(rows, cols)\n              : variant === \"pulse\"\n                ? buildPulseFrames(rows, cols)\n                : variant === \"columns\"\n                  ? buildColumnsFrames(rows, cols)\n                  : variant === \"checkerboard\"\n                    ? buildCheckerboardFrames(rows, cols)\n                    : variant === \"scan\"\n                      ? buildScanFrames(rows, cols)\n                      : variant === \"rain\"\n                        ? buildRainFrames(rows, cols)\n                        : variant === \"cascade\"\n                          ? buildCascadeFrames(rows, cols)\n                          : variant === \"sparkle\"\n                            ? buildSparkleFrames(rows, cols)\n                            : variant === \"wave-rows\"\n                              ? buildWaveRowsFrames(rows, cols)\n                              : variant === \"helix\"\n                                ? buildHelixFrames(rows, cols)\n                                : buildDiagonalSwipeFrames(rows, cols)\n\n  frameCache.set(cacheKey, frames)\n  return frames\n}\n\nexport function normalizeVariant(variant?: string): BrailleLoaderVariant {\n  if (!variant) {\n    return \"braille\"\n  }\n\n  return brailleLoaderVariants.includes(variant as BrailleLoaderVariant)\n    ? (variant as BrailleLoaderVariant)\n    : \"braille\"\n}\n\nexport function resolveGrid(\n  gridSize: BrailleGridSize = \"md\",\n  grid?: BrailleGrid\n): BrailleGrid {\n  if (!grid) {\n    return GRID_PRESETS[gridSize]\n  }\n\n  const rows = clamp(\n    Math.round(grid[0]),\n    MIN_GRID_DIMENSION,\n    MAX_GRID_DIMENSION\n  )\n  const cols = clamp(\n    Math.round(grid[1]),\n    MIN_GRID_DIMENSION,\n    MAX_GRID_DIMENSION\n  )\n\n  return [rows, cols]\n}\n\nexport function getFrameMs(\n  variant: BrailleLoaderVariant,\n  speed: BrailleLoaderSpeed\n): number {\n  const base = speedToMs[speed]\n  const multiplier = variantConfig[variant].stepMultiplier ?? 1\n  return Math.max(50, Math.round(base * multiplier))\n}\n\nexport function getFrameCount(\n  variant: BrailleLoaderVariant,\n  rows: number,\n  cols: number\n): number {\n  return getFrames(variant, rows, cols).length\n}\n\nexport function getReducedMotionFrame(\n  variant: BrailleLoaderVariant,\n  rows: number,\n  cols: number\n): Frame {\n  const frames = getFrames(variant, rows, cols)\n  return frames.find((frame) => frame.length > 0) ?? []\n}\n\nexport function isDotActive(\n  variant: BrailleLoaderVariant,\n  frameIndex: number,\n  dotIndex: number,\n  rows: number,\n  cols: number\n): boolean {\n  const frames = getFrames(variant, rows, cols)\n  const frame = frames[frameIndex % frames.length]\n  return frame.includes(dotIndex)\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}