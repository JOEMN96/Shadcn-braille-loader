{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "braille-loader",
  "title": "Braille Loader",
  "description": "Accessible braille-inspired loading indicator with 23 animation variants.",
  "files": [
    {
      "path": "registry/new-york/ui/braille-loader.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\n\nimport {\n  type BrailleGrid,\n  type BrailleGridSize,\n  type BrailleLoaderSpeed,\n  type BrailleLoaderVariant,\n  generateFrames,\n  normalizeVariant,\n  resolveGrid,\n  speedToDuration,\n} from \"@/lib/braille-loader\";\nimport { cn } from \"@/lib/utils\";\n\ntype BrailleLoaderProps = React.ComponentProps<\"div\"> & {\n  variant?: BrailleLoaderVariant;\n  gridSize?: BrailleGridSize;\n  grid?: BrailleGrid;\n  speed?: BrailleLoaderSpeed;\n  label?: string;\n  fontSize?: number;\n};\n\nfunction BrailleLoader({\n  variant = \"breathe\",\n  gridSize,\n  grid,\n  speed = \"normal\",\n  className,\n  label = \"Loading\",\n  fontSize = 28,\n  style,\n  ...props\n}: BrailleLoaderProps) {\n  const resolvedVariant = normalizeVariant(variant);\n  const [width, height] = resolveGrid(gridSize, grid);\n  const spanRef = React.useRef<HTMLSpanElement>(null);\n  const [mounted, setMounted] = React.useState(false);\n\n  const framesData = React.useMemo(() => {\n    return generateFrames(resolvedVariant, width, height);\n  }, [resolvedVariant, width, height]);\n\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  const speedMultiplier: Record<BrailleLoaderSpeed, number> = {\n    slow: 1.5,\n    normal: 1,\n    fast: 0.6,\n  };\n\n  React.useEffect(() => {\n    if (!mounted || !spanRef.current) return;\n\n    const frames = framesData.frames;\n    let frameIndex = 0;\n    const baseInterval = framesData.interval;\n    const interval = baseInterval * speedMultiplier[speed];\n\n    const updateFrame = () => {\n      if (spanRef.current) {\n        spanRef.current.textContent = frames[frameIndex];\n      }\n      frameIndex = (frameIndex + 1) % frames.length;\n    };\n\n    updateFrame();\n    const intervalId = setInterval(updateFrame, interval);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [framesData, mounted, speed]);\n\n  if (!mounted) {\n    return (\n      <div\n        role=\"status\"\n        aria-live=\"polite\"\n        className={cn(\"inline-flex items-center text-current\", className)}\n        style={style}\n        {...props}\n      >\n        <span className=\"sr-only\">{label}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      role=\"status\"\n      aria-live=\"polite\"\n      className={cn(\"inline-flex items-center text-current\", className)}\n      style={style}\n      {...props}\n    >\n      <span className=\"sr-only\">{label}</span>\n      <span\n        ref={spanRef}\n        aria-hidden=\"true\"\n        style={{\n          fontFamily: \"monospace\",\n          whiteSpace: \"pre\",\n          fontSize: `${fontSize}px`,\n          lineHeight: 1,\n          letterSpacing: 0,\n        }}\n      >\n        {framesData.frames[0]}\n      </span>\n    </div>\n  );\n}\n\nexport { BrailleLoader, type BrailleLoaderProps };\n",
      "type": "registry:component"
    },
    {
      "path": "lib/braille-loader.ts",
      "content": "export const brailleLoaderVariants = [\n  \"breathe\",\n  \"pulse\",\n  \"orbit\",\n  \"snake\",\n  \"fill-sweep\",\n  \"scan\",\n  \"rain\",\n  \"cascade\",\n  \"checkerboard\",\n  \"columns\",\n  \"wave-rows\",\n  \"diagonal-swipe\",\n  \"sparkle\",\n  \"helix\",\n  \"braille\",\n  \"interference\",\n  \"gravity-well\",\n  \"phase-shift\",\n  \"spiral\",\n  \"reflected-ripple\",\n  \"pendulum\",\n  \"compress\",\n  \"sort\",\n] as const;\n\nexport type BrailleLoaderVariant = (typeof brailleLoaderVariants)[number];\nexport type BrailleLoaderSpeed = \"slow\" | \"normal\" | \"fast\";\nexport type BrailleGridSize = \"sm\" | \"md\" | \"lg\" | \"xl\";\nexport type BrailleGrid = [rows: number, cols: number];\n\nconst GRID_PRESETS: Record<BrailleGridSize, BrailleGrid> = {\n  sm: [3, 3],\n  md: [4, 4],\n  lg: [5, 5],\n  xl: [6, 6],\n};\n\nconst MIN_GRID_DIMENSION = 2;\nconst MAX_GRID_DIMENSION = 12;\n\nexport const speedToDuration: Record<BrailleLoaderSpeed, number> = {\n  slow: 3000,\n  normal: 2400,\n  fast: 1200,\n};\n\nconst DOT_BITS = [\n  [0x01, 0x08],\n  [0x02, 0x10],\n  [0x04, 0x20],\n  [0x40, 0x80],\n];\n\nconst BRAILLE_BASE = 0x2800;\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport function seededRandom(seed: number): () => number {\n  let s = seed;\n  return () => {\n    s = (s * 1664525 + 1013904223) & 0xffffffff;\n    return (s >>> 0) / 0xffffffff;\n  };\n}\n\nfunction smoothstep(t: number): number {\n  return t * t * (3 - 2 * t);\n}\n\nfunction getCenterX(width: number): number {\n  return (width * 2 - 1) / 2;\n}\n\nfunction scaleToHeight(value: number, height: number): number {\n  return value * (height - 1);\n}\n\nfunction getThreshold(height: number): number {\n  return 0.7 + height * 0.15;\n}\n\nfunction setDot(brailleChar: number, row: number, col: number): number {\n  const safeRow = Math.min(row, 3);\n  return brailleChar | DOT_BITS[safeRow][col];\n}\n\nfunction createFieldBuffer(width: number): number[] {\n  return Array.from({ length: width }, () => BRAILLE_BASE);\n}\n\nfunction fieldToString(field: number[]): string {\n  return field.map((c) => String.fromCharCode(c)).join(\"\");\n}\n\ntype VariantConfig = {\n  totalFrames: number;\n  interval: number;\n  compute: (frame: number, totalFrames: number, width: number, height: number, context: PrecomputeContext) => number[];\n};\n\ntype PrecomputeContext = {\n  importance: number[];\n  shuffled: number[];\n  target: number[];\n  colRandom: number[];\n};\n\nconst contextCache = new Map<string, PrecomputeContext>();\n\nfunction getPrecomputeContext(width: number, height: number): PrecomputeContext {\n  const key = `${width}x${height}`;\n  let ctx = contextCache.get(key);\n  if (!ctx) {\n    const pixelCols = width * 2;\n    const totalDots = pixelCols * height;\n\n    const rand42 = seededRandom(42);\n    const importance = Array.from({ length: totalDots }, () => rand42());\n\n    const rand19 = seededRandom(19);\n    const shuffled: number[] = [];\n    const target: number[] = [];\n    for (let i = 0; i < pixelCols; i++) {\n      shuffled.push(rand19() * (height - 1));\n      target.push((i / (pixelCols - 1)) * (height - 1));\n    }\n\n    const rand123 = seededRandom(123);\n    const colRandom: number[] = [];\n    for (let pc = 0; pc < pixelCols; pc++) {\n      colRandom.push(rand123());\n    }\n\n    ctx = {\n      importance,\n      shuffled,\n      target,\n      colRandom,\n    };\n    contextCache.set(key, ctx);\n  }\n  return ctx;\n}\n\nconst VARIANT_CONFIGS: Record<string, VariantConfig> = {\n  pendulum: {\n    totalFrames: 120,\n    interval: 12,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      // One full swing across the animation duration\n      const basePhase = progress * Math.PI * 4; // 2 full oscillations (back & forth)\n      const field = createFieldBuffer(width);\n      const threshold = getThreshold(height);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        // angle varies across columns to form a curved arc\n        const angle = basePhase + (pc / (width * 2)) * Math.PI;\n        const center = scaleToHeight((Math.sin(angle) + 1) / 2, height);\n        for (let row = 0; row < height; row++) {\n          if (Math.abs(row - center) < threshold) {\n            field[Math.floor(pc / 2)] = setDot(field[Math.floor(pc / 2)], row, pc % 2);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  compress: {\n    totalFrames: 100,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, ctx) => {\n      const progress = frame / totalFrames;\n      const sieveThreshold = Math.max(0.1, 1 - progress * 1.2);\n      const squeeze = Math.min(1, progress / 0.85);\n      const activeWidth = Math.max(1, width * 2 * (1 - squeeze * 0.95));\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const mappedPc = (pc / (width * 2)) * activeWidth;\n        if (mappedPc >= activeWidth) continue;\n        const targetPc = Math.round(mappedPc);\n        if (targetPc >= width * 2) continue;\n        const charIdx = Math.floor(targetPc / 2);\n        const dc = targetPc % 2;\n        for (let row = 0; row < height; row++) {\n          const importanceIdx = pc * height + row;\n          if (ctx.importance[importanceIdx] < sieveThreshold) {\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  sort: {\n    totalFrames: 100,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, ctx) => {\n      const progress = frame / totalFrames;\n      const cursor = progress * width * 2 * 1.2;\n      const field = createFieldBuffer(width);\n      const threshold = getThreshold(height);\n      const maxRow = height - 1;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const d = pc - cursor;\n        let center: number;\n        if (d < -3) {\n          center = ctx.target[pc];\n        } else if (d < 2) {\n          const blend = 1 - (d + 3) / 5;\n          const ease = blend * blend * (3 - 2 * blend);\n          center = ctx.shuffled[pc] + (ctx.target[pc] - ctx.shuffled[pc]) * ease;\n          if (Math.abs(d) < 0.8) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            for (let r = 0; r < height; r++) {\n              field[charIdx] = setDot(field[charIdx], r, dc);\n            }\n            continue;\n          }\n        } else {\n          center =\n            ctx.shuffled[pc] +\n            Math.sin(progress * Math.PI * 16 + pc * 2.7) * 0.6 +\n            Math.sin(progress * Math.PI * 9 + pc * 1.3) * 0.4;\n        }\n        center = Math.max(0, Math.min(maxRow, center));\n        const charIdx = Math.floor(pc / 2);\n        const dc = pc % 2;\n        for (let r = 0; r < height; r++) {\n          if (Math.abs(r - center) < threshold) {\n            field[charIdx] = setDot(field[charIdx], r, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  breathe: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const phase = (Math.sin(progress * Math.PI * 2 - Math.PI / 2) + 1) / 2;\n      const field = createFieldBuffer(width);\n      const centerX = (width * 2 - 1) / 2;\n      const centerY = (height - 1) / 2;\n      const maxRadius = Math.max(centerX, centerY) * 1.1;\n      const currentRadius = phase * maxRadius;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const charIdx = Math.floor(pc / 2);\n        for (let row = 0; row < height; row++) {\n          for (let dc = 0; dc < 2; dc++) {\n            const actualPc = charIdx * 2 + dc;\n            const dx = actualPc - centerX;\n            const dy = row - centerY;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n\n            const distDiff = Math.abs(dist - currentRadius);\n            if (distDiff < 0.8) {\n              field[charIdx] = setDot(field[charIdx], row, dc);\n            }\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  pulse: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const centerX = (width * 2 - 1) / 2;\n      const centerY = (height - 1) / 2;\n      const maxRadius = Math.max(centerX, centerY);\n      const radius = progress * maxRadius;\n      const threshold = getThreshold(height);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        for (let row = 0; row < height; row++) {\n          const dx = Math.abs(pc - centerX);\n          const dy = Math.abs(row - centerY);\n          const manhattanDist = dx + dy;\n\n          if (Math.abs(manhattanDist - radius * 1.5) < threshold * 1.2) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  waveRows: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const normalized = pc / (width * 2);\n        const phase = Math.sin(progress * Math.PI * 4 + normalized * Math.PI * 3);\n        const normPhase = (phase + 1) / 2;\n\n        const charIdx = Math.floor(pc / 2);\n        const dc = pc % 2;\n        for (let row = 0; row < height; row++) {\n          const normalizedRow = row / height;\n          const wavePos = (normalizedRow + progress) % 1;\n          const waveHeight = Math.cos(wavePos * Math.PI * 2);\n\n          if (waveHeight > 0.4) {\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  snake: {\n    totalFrames: 80,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const total = width * 2;\n      const head = progress * total;\n      const field = createFieldBuffer(width);\n      const tailLength = Math.min(total / 3, 5);\n      const threshold = getThreshold(height);\n\n      for (let pc = 0; pc < total; pc++) {\n        let distance = head - pc;\n        if (distance < 0) distance += total;\n\n        const intensity = Math.max(0, 1 - distance / tailLength);\n        if (intensity > 0.1) {\n          const center = scaleToHeight(intensity * 0.8, height);\n          const currentThreshold = threshold * (0.5 + intensity * 0.5);\n\n          const charIdx = Math.floor(pc / 2);\n          const dc = pc % 2;\n          for (let row = 0; row < height; row++) {\n            if (Math.abs(row - center) < currentThreshold) {\n              field[charIdx] = setDot(field[charIdx], row, dc);\n            }\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  orbit: {\n    totalFrames: 60,\n    interval: 50,\n    compute: (frame: number, totalFrames: number, width: number, height: number, _ctx: PrecomputeContext) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      // Edge positions in clockwise order around one braille character\n      const edgePositions: Array<{row: number, dc: number}> = [\n        { row: 0, dc: 0 },  // top-left\n        { row: 0, dc: 1 },  // top-right\n        { row: 1, dc: 1 },  // right-1\n        { row: 2, dc: 1 },  // right-2\n        { row: 3, dc: 1 },  // bottom-right\n        { row: 3, dc: 0 },  // bottom-left\n        { row: 2, dc: 0 },  // left-2\n        { row: 1, dc: 0 },  // left-1\n      ];\n\n      // 3-dot trail moving clockwise\n      const leadPos = Math.floor(progress * edgePositions.length) % edgePositions.length;\n      const trailLength = 3;\n\n      // Only use first character\n      const charIdx = 0;\n\n      for (let i = 0; i < trailLength; i++) {\n        const idx = (leadPos - i + edgePositions.length) % edgePositions.length;\n        const pos = edgePositions[idx];\n\n        if (pos.row < height) {\n          field[charIdx] = setDot(field[charIdx], pos.row, pos.dc);\n        }\n      }\n\n      return field;\n    },\n  },\n\n  spiral: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const centerX = (width * 2 - 1) / 2;\n      const centerY = (height - 1) / 2;\n      const maxRadius = Math.max(centerX, centerY);\n      const spiralAngle = progress * Math.PI * 6;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const charIdx = Math.floor(pc / 2);\n        const dc = pc % 2;\n        for (let row = 0; row < height; row++) {\n          const actualPc = charIdx * 2 + dc;\n          const dx = actualPc - centerX;\n          const dy = row - centerY;\n          const dist = Math.sqrt(dx * dx + dy * dy);\n          const angle = Math.atan2(dy, dx);\n\n          if (dist < maxRadius) {\n            const normDist = dist / maxRadius;\n            const targetAngle = (spiralAngle + normDist * Math.PI * 3) % (Math.PI * 2);\n            const angleDiff = Math.abs(angle + Math.PI - targetAngle);\n            const normAngleDiff = angleDiff % (Math.PI * 2);\n            const minDiff = Math.min(normAngleDiff, Math.PI * 2 - normAngleDiff);\n\n            if (minDiff < 0.6 && dist > 0.3) {\n              field[charIdx] = setDot(field[charIdx], row, dc);\n            }\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  rain: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const charIdx = Math.floor(pc / 2);\n        const dc = pc % 2;\n\n        // Each column has a unique phase and speed\n        const columnSpeed = 1 + (pc % 3) * 0.3;\n        const columnPhase = (pc * 0.17) % 1;\n        const dropProgress = (progress * columnSpeed + columnPhase) % 1;\n\n        // Drop position (0 = top, 1 = bottom)\n        const dropPos = dropProgress * (height + 1) - 1;\n        const dropY = Math.floor(dropPos);\n\n        // Draw the drop (1-2 dots tall)\n        for (let dropOffset = 0; dropOffset < 2; dropOffset++) {\n          const actualY = dropY - dropOffset;\n          if (actualY >= 0 && actualY < height) {\n            field[charIdx] = setDot(field[charIdx], actualY, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  sparkle: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const charIdx = Math.floor(pc / 2);\n        const dc = pc % 2;\n        for (let row = 0; row < height; row++) {\n          const dotIndex = pc * height + row;\n          const sparkleOffset = dotIndex * 0.17 + frame * 0.3;\n          const sparklePhase = (sparkleOffset % 1) * Math.PI * 2;\n          const sparkle = Math.sin(sparklePhase);\n          const localRandom = seededRandom(Math.floor(dotIndex * 47));\n\n          if (sparkle > 0.5 || localRandom() > 0.8) {\n            const intensity = Math.max(0.6, sparkle) * (0.5 + localRandom() * 0.5);\n            if (intensity > 0.7) {\n              field[charIdx] = setDot(field[charIdx], row, dc);\n            }\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  checkerboard: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const phase = Math.floor(progress * 8) % 2;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        for (let row = 0; row < height; row++) {\n          // True checkerboard: alternate both X (pc) and Y (row) positions\n          if ((pc + row) % 2 === phase) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  columns: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const delay = pc / (width * 2);\n        const delta = Math.abs(delay - progress);\n        if (delta < 0.15) {\n          const charIdx = Math.floor(pc / 2);\n          const dc = pc % 2;\n          for (let row = 0; row < height; row++) {\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  cascade: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const leadingEdge = progress * 2;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const normalizedX = pc / (width * 2);\n        for (let row = 0; row < height; row++) {\n          const normalizedY = row / height;\n          const diagonalSum = normalizedX + normalizedY;\n          const delta = Math.abs(diagonalSum - leadingEdge);\n\n          if (delta < 0.2) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  diagonalSwipe: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const leadingEdge = progress * 2;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const normalizedX = pc / (width * 2);\n        for (let row = 0; row < height; row++) {\n          const normalizedY = 1 - row / height;\n          const diagonalSum = normalizedX + normalizedY;\n          const delta = Math.abs(diagonalSum - leadingEdge);\n\n          if (delta < 0.18) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  scan: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const scanPos = progress * width * 2;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const delta = Math.abs(pc - scanPos);\n        if (delta < 2) {\n          const charIdx = Math.floor(pc / 2);\n          const dc = pc % 2;\n          for (let row = 0; row < height; row++) {\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  fillSweep: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const activePc = Math.floor(progress * width * 2);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        if (pc <= activePc) {\n          const charIdx = Math.floor(pc / 2);\n          const dc = pc % 2;\n          for (let row = 0; row < height; row++) {\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  helix: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const normalized = pc / (width * 2);\n        const wave1 = Math.sin(progress * Math.PI * 6 + normalized * Math.PI * 4);\n        const wave2 = Math.cos(progress * Math.PI * 6 + normalized * Math.PI * 4 + Math.PI);\n        const combined = (wave1 + wave2 + 2) / 4;\n\n        const charIdx = Math.floor(pc / 2);\n        const dc = pc % 2;\n        for (let row = 0; row < height; row++) {\n          const rowPhase = row / height;\n          const rowMod = Math.cos(progress * Math.PI * 3 + rowPhase * Math.PI * 2) * 0.3;\n          const finalIntensity = combined + rowMod;\n\n          if (finalIntensity > 0.55) {\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  braille: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame: number, totalFrames: number, width: number, height: number, _ctx: PrecomputeContext) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      // Braille pattern positions within one character\n      const braillePath: Array<{row: number, dc: number}> = [\n        { row: 0, dc: 0 },  // top-left\n        { row: 0, dc: 1 },  // top-right\n        { row: 1, dc: 1 },  // right-top\n        { row: 2, dc: 1 },  // right-bottom\n        { row: 3, dc: 1 },  // bottom-right\n        { row: 3, dc: 0 },  // bottom-left\n        { row: 2, dc: 0 },  // left-bottom\n        { row: 1, dc: 0 },  // left-top\n      ];\n\n      // 2 moving dots (opposite positions) with 2-dot trails each\n      const lead1Index = Math.floor(progress * braillePath.length) % braillePath.length;\n      const lead2Index = Math.floor((progress + 0.5) * braillePath.length) % braillePath.length;\n\n      // Only use first character\n      const charIdx = 0;\n\n      // First moving dot with 2-dot trail\n      for (let i = 0; i < 2; i++) {\n        const idx = (lead1Index - i + braillePath.length) % braillePath.length;\n        const pos = braillePath[idx];\n        if (pos.row < height) {\n          field[charIdx] = setDot(field[charIdx], pos.row, pos.dc);\n        }\n      }\n\n      // Second moving dot with 2-dot trail (opposite)\n      for (let i = 0; i < 2; i++) {\n        const idx = (lead2Index - i + braillePath.length) % braillePath.length;\n        const pos = braillePath[idx];\n        if (pos.row < height) {\n          field[charIdx] = setDot(field[charIdx], pos.row, pos.dc);\n        }\n      }\n\n      return field;\n    },\n  },\n\n  interference: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const normalizedX = pc / (width * 2);\n        for (let row = 0; row < height; row++) {\n          const normalizedY = row / height;\n          const wave1 = Math.sin(progress * Math.PI * 4 + normalizedX * Math.PI * 3);\n          const wave2 = Math.cos(progress * Math.PI * 3 + normalizedY * Math.PI * 2.5);\n          const wave3 = Math.sin(progress * Math.PI * 2 + (normalizedX + normalizedY) * Math.PI * 2);\n          const combined = (wave1 + wave2 + wave3) / 3;\n          const intensity = (combined + 1) / 2;\n\n          if (intensity > 0.35) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  gravityWell: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const centerX = (width * 2 - 1) / 2;\n      const centerY = (height - 1) / 2;\n      const maxRadius = Math.max(centerX, centerY);\n      const phase = (Math.sin(progress * Math.PI * 4) + 1) / 2;\n      const pullRadius = phase * maxRadius;\n      const rand = seededRandom(frame);\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        for (let row = 0; row < height; row++) {\n          const dx = pc - centerX;\n          const dy = row - centerY;\n          const dist = Math.sqrt(dx * dx + dy * dy);\n\n          if (dist < pullRadius) {\n            const intensity = 1 - (dist / pullRadius) * 0.7;\n            const dotIndex = pc * height + row;\n            const noise = rand();\n            if (noise < intensity * 0.5 + 0.1) {\n              const charIdx = Math.floor(pc / 2);\n              const dc = pc % 2;\n              field[charIdx] = setDot(field[charIdx], row, dc);\n            }\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  phaseShift: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const centerX = (width * 2 - 1) / 2;\n      const centerY = (height - 1) / 2;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        for (let row = 0; row < height; row++) {\n          const dx = pc - centerX;\n          const dy = row - centerY;\n\n          let phaseOffset = 0;\n          if (dx >= 0 && dy >= 0) phaseOffset = 0;\n          else if (dx < 0 && dy >= 0) phaseOffset = Math.PI / 2;\n          else if (dx < 0 && dy < 0) phaseOffset = Math.PI;\n          else phaseOffset = Math.PI * 1.5;\n\n          const phase = Math.sin(progress * Math.PI * 3 + phaseOffset);\n          const intensity = (phase + 1) / 2;\n\n          if (intensity > 0.35) {\n            const charIdx = Math.floor(pc / 2);\n            const dc = pc % 2;\n            field[charIdx] = setDot(field[charIdx], row, dc);\n          }\n        }\n      }\n      return field;\n    },\n  },\n\n  reflectedRipple: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames;\n      const field = createFieldBuffer(width);\n      const phase = progress < 0.5 ? progress * 2 : (1 - progress) * 2;\n      const centerX = (width * 2 - 1) / 2;\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const distFromCenter = Math.abs(pc - centerX);\n        const normalizedDist = distFromCenter / centerX;\n        const edgePos = phase * centerX;\n        const delta = Math.abs(distFromCenter - edgePos);\n\n        if (delta < 1.5) {\n          const intensity = 1 - delta / 1.5;\n          for (let row = 0; row < height; row++) {\n            const rowIntensity = intensity * (1 - Math.abs(row - (height - 1) / 2) / (height / 2));\n            if (rowIntensity > 0.3) {\n              const charIdx = Math.floor(pc / 2);\n              const dc = pc % 2;\n              field[charIdx] = setDot(field[charIdx], row, dc);\n            }\n          }\n        }\n      }\n      return field;\n    },\n  },\n};\n\nfunction toCamelCase(str: string): string {\n  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\nconst frameCache = new Map<string, string[]>();\n\nexport function generateFrames(variant: string, width: number, height: number): { frames: string[]; interval: number } {\n  const key = `${variant}-${width}x${height}`;\n  const cached = frameCache.get(key);\n  if (cached) {\n    return { frames: cached, interval: VARIANT_CONFIGS[toCamelCase(variant)]?.interval || 40 };\n  }\n\n  const config = VARIANT_CONFIGS[toCamelCase(variant)];\n  if (!config) {\n    return { frames: [fieldToString(createFieldBuffer(width))], interval: 40 };\n  }\n\n  const context = getPrecomputeContext(width, height);\n  const frames: string[] = [];\n\n  for (let frame = 0; frame < config.totalFrames; frame++) {\n    const field = config.compute(frame, config.totalFrames, width, height, context);\n    frames.push(fieldToString(field));\n  }\n\n  frameCache.set(key, frames);\n  return { frames, interval: config.interval };\n}\n\nexport function resolveGrid(gridSize?: BrailleGridSize, grid?: BrailleGrid): [number, number] {\n  if (grid) {\n    const rows = clamp(Math.round(grid[0]), MIN_GRID_DIMENSION, MAX_GRID_DIMENSION);\n    const cols = clamp(Math.round(grid[1]), MIN_GRID_DIMENSION, MAX_GRID_DIMENSION);\n    return [cols, rows];\n  }\n  if (gridSize) return [GRID_PRESETS[gridSize][1], GRID_PRESETS[gridSize][0]];\n  return [4, 4];\n}\n\nexport function normalizeVariant(variant?: string): BrailleLoaderVariant {\n  if (!variant) return \"breathe\";\n  return brailleLoaderVariants.includes(variant as BrailleLoaderVariant) ? (variant as BrailleLoaderVariant) : \"breathe\";\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}