{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "braille-loader",
  "title": "Braille Loader",
  "description": "Accessible braille-inspired loading indicator with 23 animation variants.",
  "files": [
    {
      "path": "registry/new-york/ui/braille-loader.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\n\nimport {\n  type BrailleGrid,\n  type BrailleGridSize,\n  type BrailleLoaderSpeed,\n  type BrailleLoaderVariant,\n  generateFrames,\n  normalizeVariant,\n  resolveGrid,\n  speedToDuration,\n} from \"@/lib/braille-loader\"\nimport { cn } from \"@/lib/utils\"\n\ntype BrailleLoaderProps = React.ComponentProps<\"div\"> & {\n  variant?: BrailleLoaderVariant\n  gridSize?: BrailleGridSize\n  grid?: BrailleGrid\n  speed?: BrailleLoaderSpeed\n  label?: string\n  fontSize?: number\n}\n\nfunction BrailleLoader({\n  variant = \"breathe\",\n  gridSize,\n  grid,\n  speed = \"normal\",\n  className,\n  label = \"Loading\",\n  fontSize = 28,\n  style,\n  ...props\n}: BrailleLoaderProps) {\n  const resolvedVariant = normalizeVariant(variant)\n  const [width, height] = resolveGrid(gridSize, grid)\n  const spanRef = React.useRef<HTMLSpanElement>(null)\n  const [mounted, setMounted] = React.useState(false)\n\n  const framesData = React.useMemo(() => {\n    return generateFrames(resolvedVariant, width, height)\n  }, [resolvedVariant, width, height])\n\n  React.useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  const speedMultiplier: Record<BrailleLoaderSpeed, number> = {\n    slow: 1.5,\n    normal: 1,\n    fast: 0.6,\n  }\n\n  React.useEffect(() => {\n    if (!mounted || !spanRef.current) return\n\n    const frames = framesData.frames\n    let frameIndex = 0\n    const baseInterval = framesData.interval\n    const interval = baseInterval * speedMultiplier[speed]\n\n    const updateFrame = () => {\n      if (spanRef.current) {\n        spanRef.current.textContent = frames[frameIndex]\n      }\n      frameIndex = (frameIndex + 1) % frames.length\n    }\n\n    updateFrame()\n    const intervalId = setInterval(updateFrame, interval)\n\n    return () => {\n      clearInterval(intervalId)\n    }\n  }, [framesData, mounted, speed])\n\n  if (!mounted) {\n    return (\n      <div\n        role=\"status\"\n        aria-live=\"polite\"\n        className={cn(\"inline-flex items-center text-current\", className)}\n        style={style}\n        {...props}\n      >\n        <span className=\"sr-only\">{label}</span>\n      </div>\n    )\n  }\n\n  return (\n    <div\n      role=\"status\"\n      aria-live=\"polite\"\n      className={cn(\"inline-flex items-center text-current\", className)}\n      style={style}\n      {...props}\n    >\n      <span className=\"sr-only\">{label}</span>\n      <span\n        ref={spanRef}\n        aria-hidden=\"true\"\n        style={{\n          fontFamily: \"monospace\",\n          whiteSpace: \"pre\",\n          fontSize: `${fontSize}px`,\n          lineHeight: 1,\n          letterSpacing: 0,\n        }}\n      >\n        {framesData.frames[0]}\n      </span>\n    </div>\n  )\n}\n\nexport { BrailleLoader, type BrailleLoaderProps }\n",
      "type": "registry:component"
    },
    {
      "path": "lib/braille-loader.ts",
      "content": "export const brailleLoaderVariants = [\n  \"breathe\",\n  \"pulse\",\n  \"orbit\",\n  \"snake\",\n  \"fill-sweep\",\n  \"scan\",\n  \"rain\",\n  \"cascade\",\n  \"checkerboard\",\n  \"columns\",\n  \"wave-rows\",\n  \"diagonal-swipe\",\n  \"sparkle\",\n  \"helix\",\n  \"braille\",\n  \"interference\",\n  \"gravity-well\",\n  \"phase-shift\",\n  \"spiral\",\n  \"reflected-ripple\",\n  \"pendulum\",\n  \"compress\",\n  \"sort\",\n] as const\n\nexport type BrailleLoaderVariant = (typeof brailleLoaderVariants)[number]\nexport type BrailleLoaderSpeed = \"slow\" | \"normal\" | \"fast\"\nexport type BrailleGridSize = \"sm\" | \"md\" | \"lg\" | \"xl\"\nexport type BrailleGrid = [rows: number, cols: number]\n\nconst GRID_PRESETS: Record<BrailleGridSize, BrailleGrid> = {\n  sm: [3, 3],\n  md: [4, 4],\n  lg: [5, 5],\n  xl: [6, 6],\n}\n\nconst MIN_GRID_DIMENSION = 2\nconst MAX_GRID_DIMENSION = 12\n\nexport const speedToDuration: Record<BrailleLoaderSpeed, number> = {\n  slow: 3000,\n  normal: 2400,\n  fast: 1200,\n}\n\nconst DOT_BITS = [\n  [0x01, 0x08],\n  [0x02, 0x10],\n  [0x04, 0x20],\n  [0x40, 0x80],\n]\n\nconst BRAILLE_BASE = 0x2800\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(max, Math.max(min, value))\n}\n\nexport function seededRandom(seed: number): () => number {\n  let s = seed\n  return () => {\n    s = (s * 1664525 + 1013904223) & 0xffffffff\n    return (s >>> 0) / 0xffffffff\n  }\n}\n\nfunction smoothstep(t: number): number {\n  return t * t * (3 - 2 * t)\n}\n\nfunction setDot(brailleChar: number, row: number, col: number): number {\n  return brailleChar | DOT_BITS[row][col]\n}\n\nfunction createFieldBuffer(width: number): number[] {\n  return Array.from({ length: width }, () => BRAILLE_BASE)\n}\n\nfunction fieldToString(field: number[]): string {\n  return field.map((c) => String.fromCharCode(c)).join(\"\")\n}\n\ntype VariantConfig = {\n  totalFrames: number\n  interval: number\n  compute: (frame: number, totalFrames: number, width: number, height: number, context: PrecomputeContext) => number[]\n}\n\ntype PrecomputeContext = {\n  importance: number[]\n  shuffled: number[]\n  target: number[]\n  snakePath: [number, number][]\n  rainOffsets: number[]\n  sparkleOffsets: number[][]\n}\n\nconst contextCache = new Map<string, PrecomputeContext>()\n\nfunction getPrecomputeContext(width: number, height: number): PrecomputeContext {\n  const key = `${width}x${height}`\n  let ctx = contextCache.get(key)\n  if (!ctx) {\n    const pixelCols = width * 2\n    const pixelRows = height * 4\n    const totalDots = pixelCols * pixelRows\n\n    const rand42 = seededRandom(42)\n    const importance = Array.from({ length: totalDots }, () => rand42())\n\n    const rand19 = seededRandom(19)\n    const shuffled: number[] = []\n    const target: number[] = []\n    for (let i = 0; i < pixelCols; i++) {\n      shuffled.push(rand19() * (pixelRows - 1))\n      target.push((i / (pixelCols - 1)) * (pixelRows - 1))\n    }\n\n    const snakePath: [number, number][] = []\n    for (let row = 0; row < height; row++) {\n      const isEven = row % 2 === 0\n      for (let i = 0; i < width; i++) {\n        const col = isEven ? i : width - 1 - i\n        snakePath.push([row, col])\n      }\n    }\n\n    const rainOffsets = Array.from({ length: width }, () => {\n      const r = seededRandom(width * 7919)\n      return r()\n    })\n\n    const sparkleOffsets: number[][] = []\n    for (let row = 0; row < height; row++) {\n      sparkleOffsets.push(\n        Array.from({ length: width }, () => {\n          const r = seededRandom(width * height * 3137 + row)\n          return r()\n        }),\n      )\n    }\n\n    ctx = {\n      importance,\n      shuffled,\n      target,\n      snakePath,\n      rainOffsets,\n      sparkleOffsets,\n    }\n    contextCache.set(key, ctx)\n  }\n  return ctx\n}\n\nfunction toCamelCase(str: string): string {\n  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())\n}\n\nconst VARIANT_CONFIGS: Record<string, VariantConfig> = {\n  pendulum: {\n    totalFrames: 120,\n    interval: 12,\n    compute: (frame, totalFrames, width, _height, _ctx) => {\n      const progress = frame / totalFrames\n      const spread = Math.sin(Math.PI * progress) * 1.0\n      const basePhase = progress * Math.PI * 8\n      const field = createFieldBuffer(width)\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const swing = Math.sin(basePhase + pc * spread)\n        const center = (1 - swing) * 1.5\n        for (let row = 0; row < 4; row++) {\n          if (Math.abs(row - center) < 0.7) {\n            field[Math.floor(pc / 2)] = setDot(field[Math.floor(pc / 2)], row, pc % 2)\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  compress: {\n    totalFrames: 100,\n    interval: 40,\n    compute: (frame, totalFrames, width, _height, ctx) => {\n      const progress = frame / totalFrames\n      const sieveThreshold = Math.max(0.1, 1 - progress * 1.2)\n      const squeeze = Math.min(1, progress / 0.85)\n      const activeWidth = Math.max(1, width * 2 * (1 - squeeze * 0.95))\n      const field = createFieldBuffer(width)\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const mappedPc = (pc / (width * 2)) * activeWidth\n        if (mappedPc >= activeWidth) continue\n        const targetPc = Math.round(mappedPc)\n        if (targetPc >= width * 2) continue\n        const charIdx = Math.floor(targetPc / 2)\n        const dc = targetPc % 2\n        for (let row = 0; row < 4; row++) {\n          const importanceIdx = pc * 4 + row\n          if (ctx.importance[importanceIdx] < sieveThreshold) {\n            field[charIdx] = setDot(field[charIdx], row, dc)\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  sort: {\n    totalFrames: 100,\n    interval: 40,\n    compute: (frame, totalFrames, width, _height, ctx) => {\n      const progress = frame / totalFrames\n      const cursor = progress * width * 2 * 1.2\n      const field = createFieldBuffer(width)\n\n      for (let pc = 0; pc < width * 2; pc++) {\n        const d = pc - cursor\n        let center: number\n        if (d < -3) {\n          center = ctx.target[pc]\n        } else if (d < 2) {\n          const blend = 1 - (d + 3) / 5\n          const ease = blend * blend * (3 - 2 * blend)\n          center = ctx.shuffled[pc] + (ctx.target[pc] - ctx.shuffled[pc]) * ease\n          if (Math.abs(d) < 0.8) {\n            const charIdx = Math.floor(pc / 2)\n            const dc = pc % 2\n            for (let r = 0; r < 4; r++) {\n              field[charIdx] = setDot(field[charIdx], r, dc)\n            }\n            continue\n          }\n        } else {\n          center =\n            ctx.shuffled[pc] +\n            Math.sin(progress * Math.PI * 16 + pc * 2.7) * 0.6 +\n            Math.sin(progress * Math.PI * 9 + pc * 1.3) * 0.4\n        }\n        center = Math.max(0, Math.min(3, center))\n        const charIdx = Math.floor(pc / 2)\n        const dc = pc % 2\n        for (let r = 0; r < 4; r++) {\n          if (Math.abs(r - center) < 0.7) {\n            field[charIdx] = setDot(field[charIdx], r, dc)\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  breathe: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const phase = (Math.sin(progress * Math.PI * 2) + 1) / 2\n      const field = createFieldBuffer(width)\n      const cx = width / 2\n      const cy = height / 2\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const dx = col - cx\n          const dy = row - cy\n          const dist = Math.sqrt(dx * dx + dy * dy)\n          const maxDist = Math.sqrt(cx * cx + cy * cy)\n          const normalized = maxDist > 0 ? dist / maxDist : 0\n          const energy = smoothstep(clamp(1 - normalized * 2, 0, 1)) * phase\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  pulse: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const cx = width / 2\n      const cy = height / 2\n      const maxDist = Math.sqrt(cx * cx + cy * cy)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const dx = col - cx\n          const dy = row - cy\n          const dist = Math.sqrt(dx * dx + dy * dy)\n          const normalized = maxDist > 0 ? dist / maxDist : 0\n          const delta = Math.abs(normalized - progress)\n          const energy = smoothstep(clamp(1 - delta * 5, 0, 1))\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  waveRows: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let row = 0; row < height; row++) {\n        const phase = Math.sin(progress * Math.PI * 2 + row * 0.5)\n        const energy = (phase + 1) / 2\n        for (let col = 0; col < width; col++) {\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy * 0.8) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  snake: {\n    totalFrames: 80,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, ctx) => {\n      const progress = frame / totalFrames\n      const total = ctx.snakePath.length\n      const head = progress * total\n      const field = createFieldBuffer(width)\n\n      for (let i = 0; i < total; i++) {\n        let distance = head - i\n        if (distance < 0) distance += total\n        const energy = Math.exp(-distance * 0.3)\n\n        if (energy > 0.2) {\n          const [row, col] = ctx.snakePath[i]\n          for (let r = 0; r < 4; r++) {\n            if (Math.random() < energy) {\n              field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  orbit: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const cx = width / 2\n      const cy = height / 2\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const angle = Math.atan2(row - cy, col - cx)\n          const normAngle = ((angle + Math.PI) / (Math.PI * 2) + progress) % 1\n          const energy = smoothstep(clamp(1 - Math.abs(normAngle - 0.5) * 4, 0, 1))\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  spiral: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const cx = width / 2\n      const cy = height / 2\n      const maxDist = Math.sqrt(cx * cx + cy * cy)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const angle = Math.atan2(row - cy, col - cx)\n          const radius = Math.sqrt(Math.pow(row - cy, 2) + Math.pow(col - cx, 2))\n          const normRadius = maxDist > 0 ? radius / maxDist : 0\n          const normAngle = ((angle + Math.PI) / (Math.PI * 2) + progress) % 1\n          const spiralIndex = (normAngle + normRadius * 0.5) % 1\n          const delta = Math.abs(spiralIndex - progress)\n          const energy = smoothstep(clamp(1 - delta * 10, 0, 1))\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  rain: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let col = 0; col < width; col++) {\n        const local = (progress + ctx.rainOffsets[col]) % 1\n        const activeRow = Math.floor(local * height)\n        const row = height - 1 - activeRow\n        if (row >= 0 && row < height) {\n          for (let r = 0; r < 4; r++) {\n            field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  sparkle: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const offset = ctx.sparkleOffsets[row][col]\n          const local = (progress + offset) % 1\n          const pulse = Math.sin(local * Math.PI * 2)\n          if (pulse > 0.6) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < (pulse + 1) / 2) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  checkerboard: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const phase = Math.floor(progress * 2) % 2\n      const field = createFieldBuffer(width)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          if ((row + col) % 2 === phase) {\n            for (let r = 0; r < 4; r++) {\n              field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  columns: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, _height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let col = 0; col < width; col++) {\n        const delay = col / width\n        const delta = Math.abs(delay - progress)\n        if (delta < 0.15) {\n          for (let r = 0; r < 4; r++) {\n            field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  cascade: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const delay = (row + col) / (width + height)\n          const delta = Math.abs(delay - progress)\n          if (delta < 0.1) {\n            for (let r = 0; r < 4; r++) {\n              field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  diagonalSwipe: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const position = (row - col) / height\n          const delta = Math.abs(position - (progress * 2 - 1))\n          if (delta < 0.15) {\n            for (let r = 0; r < 4; r++) {\n              field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  scan: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const scanRow = Math.floor(progress * height)\n\n      for (let col = 0; col < width; col++) {\n        const row = height - 1 - scanRow\n        if (row >= 0 && row < height) {\n          for (let r = 0; r < 4; r++) {\n            field[col] = setDot(field[col], r, Math.random() > 0.3 ? 0 : 1)\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  fillSweep: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const activeRow = Math.floor(progress * height)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          if (row <= activeRow) {\n            for (let r = 0; r < 4; r++) {\n              field[col] = setDot(field[col], r, Math.random() > 0.2 ? 0 : 1)\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  helix: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const cx = width / 2\n      const cy = height / 2\n      const maxDist = Math.sqrt(cx * cx + cy * cy)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const angle = Math.atan2(row - cy, col - cx)\n          const radius = Math.sqrt(Math.pow(row - cy, 2) + Math.pow(col - cx, 2))\n          const normRadius = maxDist > 0 ? radius / maxDist : 0\n          const normAngle = ((angle + Math.PI) / (Math.PI * 2) + progress * 2) % 1\n          const k = 0.5\n          const spiralIndex = (normAngle + normRadius * k) % 1\n          const delta = Math.abs(spiralIndex - progress)\n          const energy = smoothstep(clamp(1 - delta * 8, 0, 1))\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  braille: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const clusterRows = Math.ceil(height / 3)\n      const clusterCols = Math.ceil(width / 2)\n      const totalClusters = clusterRows * clusterCols\n      const activeCluster = Math.floor(progress * totalClusters)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const clusterRow = Math.floor(row / 3)\n          const clusterCol = Math.floor(col / 2)\n          const clusterIndex = clusterRow * clusterCols + clusterCol\n          if (clusterIndex === activeCluster) {\n            for (let r = 0; r < 4; r++) {\n              field[col] = setDot(field[col], r, Math.random() > 0.3 ? 0 : 1)\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  interference: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const waveA = Math.sin(progress * Math.PI * 2 + row * 0.6)\n          const waveB = Math.sin(progress * Math.PI * 2 + col * 0.6)\n          const combined = (waveA + waveB) / 2\n          const energy = (combined + 1) / 2\n\n          if (energy > 0.4) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  gravityWell: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const cx = width / 2\n      const cy = height / 2\n      const phase = Math.sin(progress * Math.PI * 2)\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          const dx = col - cx\n          const dy = row - cy\n          const dist = Math.sqrt(dx * dx + dy * dy)\n          const maxDist = Math.sqrt(cx * cx + cy * cy)\n          const norm = maxDist > 0 ? dist / maxDist : 0\n          const energy = ((1 - norm) * (phase + 1)) / 2\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  phaseShift: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const midRow = height / 2\n      const midCol = width / 2\n\n      for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n          let phaseOffset = 0\n          if (row < midRow && col >= midCol) phaseOffset = Math.PI / 2\n          else if (row >= midRow && col < midCol) phaseOffset = Math.PI\n          else if (row >= midRow && col >= midCol) phaseOffset = (3 * Math.PI) / 2\n          const phase = Math.sin(progress * Math.PI * 2 + phaseOffset)\n          const energy = (phase + 1) / 2\n\n          if (energy > 0.3) {\n            for (let r = 0; r < 4; r++) {\n              if (Math.random() < energy) {\n                field[col] = setDot(field[col], r, Math.random() > 0.5 ? 0 : 1)\n              }\n            }\n          }\n        }\n      }\n      return field\n    },\n  },\n\n  reflectedRipple: {\n    totalFrames: 60,\n    interval: 40,\n    compute: (frame, totalFrames, width, _height, _ctx) => {\n      const progress = frame / totalFrames\n      const field = createFieldBuffer(width)\n      const position = progress < 0.5 ? progress * 4 : (1 - progress) * 4\n\n      for (let col = 0; col < width; col++) {\n        const normalized = col / width\n        const delta = Math.abs(normalized - position)\n        if (delta < 0.15) {\n          for (let r = 0; r < 4; r++) {\n            field[col] = setDot(field[col], r, Math.random() > 0.2 ? 0 : 1)\n          }\n        }\n      }\n      return field\n    },\n  },\n}\n\nconst frameCache = new Map<string, string[]>()\n\nexport function generateFrames(variant: string, width: number, height: number): { frames: string[]; interval: number } {\n  const key = `${variant}-${width}x${height}`\n  const cached = frameCache.get(key)\n  if (cached) {\n    return { frames: cached, interval: VARIANT_CONFIGS[toCamelCase(variant)]?.interval || 40 }\n  }\n\n  const config = VARIANT_CONFIGS[toCamelCase(variant)]\n  if (!config) {\n    return { frames: [fieldToString(createFieldBuffer(width))], interval: 40 }\n  }\n\n  const context = getPrecomputeContext(width, height)\n  const frames: string[] = []\n\n  for (let frame = 0; frame < config.totalFrames; frame++) {\n    const field = config.compute(frame, config.totalFrames, width, height, context)\n    frames.push(fieldToString(field))\n  }\n\n  frameCache.set(key, frames)\n  return { frames, interval: config.interval }\n}\n\nexport function resolveGrid(gridSize?: BrailleGridSize, grid?: BrailleGrid): [number, number] {\n  if (grid) {\n    const rows = clamp(Math.round(grid[0]), MIN_GRID_DIMENSION, MAX_GRID_DIMENSION)\n    const cols = clamp(Math.round(grid[1]), MIN_GRID_DIMENSION, MAX_GRID_DIMENSION)\n    return [cols, rows]\n  }\n  if (gridSize) return [GRID_PRESETS[gridSize][1], GRID_PRESETS[gridSize][0]]\n  return [4, 4]\n}\n\nexport function normalizeVariant(variant?: string): BrailleLoaderVariant {\n  if (!variant) return \"breathe\"\n  return brailleLoaderVariants.includes(variant as BrailleLoaderVariant) ? (variant as BrailleLoaderVariant) : \"breathe\"\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}
